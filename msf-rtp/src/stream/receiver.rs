//! RTP receiver and related statistics.

use std::{
    collections::{HashMap, VecDeque},
    num::NonZeroUsize,
    pin::Pin,
    task::{Context, Poll},
    time::{Duration, Instant},
};

use futures::{ready, Stream};
use lru::LruCache;

use crate::{
    rtcp::{ReceiverReport, ReportBlock, RtcpPacket, SenderReport},
    rtp::{IncomingRtpPacket, RtpPacket},
    stream::DurationExt,
    utils::{OrderedRtpPacket, ReorderingMultiBuffer, ReorderingError},
};

/// RTP packet receiver.
pub trait RtpReceiver<E>: Stream<Item = Result<OrderedRtpPacket, E>> {
    /// Create receiver report.
    ///
    /// This method should generate a single receiver report for all SSRCs that
    /// appeared since the last call to this method.
    fn create_receiver_report(&mut self) -> RtcpPacket;

    /// Process a given sender report.
    fn process_sender_report(&mut self, report: &SenderReport);
}

/// SSRC handling mode.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum SSRCMode {
    /// Ignore incoming SSRCs and treat all packets as belonging to a single
    /// SSRC.
    ///
    /// This mode is useful when dealing with buggy peers that change SSRCs
    /// unexpectedly. The receiver reports will use the last seen SSRC.
    Ignore,

    /// Accept packets with any SSRC.
    Any,

    /// Accept packets only from specific SSRCs.
    Specific,
}

/// RTP receiver options.
#[derive(Clone)]
pub struct RtpReceiverOptions {
    sender_ssrc: u32,
    reordering_buffer_depth: usize,
    default_clock_rate: u32,
    input_ssrc_mode: SSRCMode,
    max_input_ssrcs: Option<usize>,
    input_ssrcs: HashMap<u32, u32>,
    max_rtcp_packet_size: usize,
}

impl RtpReceiverOptions {
    /// Create new options.
    pub fn new() -> Self {
        Self {
            sender_ssrc: rand::random(),
            reordering_buffer_depth: 64,
            default_clock_rate: 90000,
            input_ssrc_mode: SSRCMode::Any,
            max_input_ssrcs: Some(64),
            input_ssrcs: HashMap::new(),
            max_rtcp_packet_size: 1500,
        }
    }

    /// Set the sender SSRC.
    ///
    /// This SSRC will be used as the sender SSRC in RTCP receiver reports
    /// generated by the receiver.
    #[inline]
    pub fn sender_ssrc(mut self, ssrc: u32) -> Self {
        self.sender_ssrc = ssrc;
        self
    }

    /// Set depth of the reordering buffer for incoming RTP packets.
    ///
    /// The default value is 64.
    #[inline]
    pub fn reordering_buffer_depth(mut self, depth: usize) -> Self {
        self.reordering_buffer_depth = depth;
        self
    }

    /// Set the default clock rate for SSRCs without an explicit clock rate.
    ///
    /// This clock rate will be used when creating sender and receiver reports
    /// for SSRCs where the clock rate is not known. The default value is
    /// 90000.
    #[inline]
    pub fn default_clock_rate(mut self, clock_rate: u32) -> Self {
        self.default_clock_rate = clock_rate;
        self
    }

    /// Set the input SSRC handling mode.
    ///
    /// The default mode is `SSRCMode::Any`.
    #[inline]
    pub fn input_ssrc_mode(mut self, mode: SSRCMode) -> Self {
        self.input_ssrc_mode = mode;
        self
    }

    /// Set the maximum number of input SSRCs to track.
    ///
    /// This option is valid only when `input_ssrc_mode` is set to
    /// `SSRCMode::Any`. Setting this option to `None` will allow unlimited
    /// number of SSRCs. This should be used with caution as it may lead to
    /// excessive memory usage. The default limit is 64 SSRCs.
    ///
    /// If there are more SSRCs than the limit, the least recently used SSRCs
    /// will be dropped first.
    #[inline]
    pub fn max_input_ssrcs(mut self, max: Option<usize>) -> Self {
        self.max_input_ssrcs = max;
        self
    }

    /// Set the expected input SSRCs along with their clock rates.
    ///
    /// The clock rate is used for generating RTCP receiver reports. The method
    /// accepts an iterator of `(ssrc, clock_rate)` tuples.
    ///
    /// Note that if the clock rate for a given SSRC is not specified here, the
    /// default clock rate will be used instead when generating receiver
    /// reports. This may lead to incorrect reports if the actual clock rate
    /// differs from the default one.
    pub fn input_ssrcs<T>(mut self, ssrcs: T) -> Self
    where
        T: IntoIterator<Item = (u32, u32)>,
    {
        self.input_ssrcs = HashMap::from_iter(ssrcs.into_iter());
        self
    }

    /// Set the maximum RTCP packet size.
    #[inline]
    pub fn max_rtcp_packet_size(mut self, size: usize) -> Self {
        self.max_rtcp_packet_size = size;
        self
    }
}

impl Default for RtpReceiverOptions {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}

pin_project_lite::pin_project! {
    /// Default RTP receiver implementation.
    pub struct DefaultRtpReceiver<T, E> {
        #[pin]
        inner: Option<T>,
        context: RtpReceiverContext,
        error: Option<E>,
    }
}

impl<T, E> DefaultRtpReceiver<T, E> {
    /// Create a new RTP packet receiver.
    pub fn new(stream: T, options: RtpReceiverOptions) -> Self {
        Self {
            inner: Some(stream),
            context: RtpReceiverContext::new(options),
            error: None,
        }
    }
}

impl<T, E> Stream for DefaultRtpReceiver<T, E>
where
    T: Stream<Item = Result<RtpPacket, E>>,
{
    type Item = Result<OrderedRtpPacket, E>;

    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        let mut this = self.project();

        loop {
            if let Some(packet) = this.context.next() {
                return Poll::Ready(Some(Ok(packet)));
            }

            let inner = this.inner.as_mut();

            if let Some(inner) = inner.as_pin_mut() {
                match ready!(inner.poll_next(cx)) {
                    Some(Ok(packet)) => this.context.push(packet),
                    other => {
                        if let Some(Err(err)) = other {
                            *this.error = Some(err);
                        }

                        this.inner.set(None);
                    }
                }
            } else  if let Some(packet) = this.context.take() {
                return Poll::Ready(Some(Ok(packet)));
            } else if let Some(err) = this.error.take() {
                return Poll::Ready(Some(Err(err)));
            } else {
                return Poll::Ready(None);
            }
        }
    }
}

impl<T, E> RtpReceiver<E> for DefaultRtpReceiver<T, E>
where
    T: Stream<Item = Result<RtpPacket, E>>,
{
    fn create_receiver_report(&mut self) -> RtcpPacket {
        self.context.create_receiver_report()
    }

    fn process_sender_report(&mut self, report: &SenderReport) {
        self.context.process_sender_report(report);
    }
}

/// RTP receiver context.
struct RtpReceiverContext {
    options: RtpReceiverOptions,
    buffer: ReorderingMultiBuffer,
    output: VecDeque<OrderedRtpPacket>,
    stats: LruCache<u32, SSRCRxStats>,
    last_ssrc: Option<u32>,
}

impl RtpReceiverContext {
    /// Create a new RTP receiver context.
    fn new(options: RtpReceiverOptions) -> Self {
        let expected_ssrcs = options.input_ssrcs.len();

        let max_input_ssrcs = options
            .max_input_ssrcs
            .map(|max| max.max(expected_ssrcs));

        let max_ssrc_buffers = match options.input_ssrc_mode {
            SSRCMode::Ignore => Some(1),
            SSRCMode::Any => max_input_ssrcs,
            SSRCMode::Specific => Some(expected_ssrcs),
        };

        let buffer = ReorderingMultiBuffer::new(options.reordering_buffer_depth, max_ssrc_buffers);

        let stats = if let (SSRCMode::Any, Some(max)) = (options.input_ssrc_mode, max_input_ssrcs) {
            let max = NonZeroUsize::new(max)
                .unwrap_or(NonZeroUsize::MIN);

            LruCache::new(max)
        } else {
            LruCache::unbounded()
        };

        Self {
            options,
            buffer,
            output: VecDeque::new(),
            stats,
            last_ssrc: None,
        }
    }

    /// Push a given RTP packet into the reordering buffer.
    fn push(&mut self, mut packet: RtpPacket) {
        let ssrc = packet.ssrc();

        match self.options.input_ssrc_mode {
            SSRCMode::Ignore => packet = packet.with_ssrc(0),
            SSRCMode::Specific if !self.options.input_ssrcs.contains_key(&ssrc) => return,
            _ => (),
        }

        self.last_ssrc = Some(ssrc);

        let now = Instant::now();

        self.push_incoming(IncomingRtpPacket::new(packet, now));
    }

    /// Push a given RTP packet into the reordering buffer.
    fn push_incoming(&mut self, mut packet: IncomingRtpPacket) {
        let ssrc = packet.ssrc();

        self.get_stats_mut(ssrc)
            .process_incoming_packet(&packet);

        // put the packet into the reordering buffer, skipping missing packets
        // if necessary
        while let Err(ReorderingError::BufferFull(tmp)) = self.buffer.push(packet) {
            if let Some(p) = self.buffer.take() {
                self.push_ordered(p);
            }

            packet = tmp;
        }

        // take all in-order packets from the reordering buffer
        while let Some(p) = self.buffer.next() {
            self.push_ordered(p);
        }
    }

    /// Push a given ordered RTP packet to the output queue.
    fn push_ordered(&mut self, packet: OrderedRtpPacket) {
        let ssrc = packet.ssrc();

        self.get_stats_mut(ssrc)
            .process_ordered_packet(&packet);

        self.output.push_back(packet);
    }

    /// Take the next in-order packet without skipping missing packets.
    fn next(&mut self) -> Option<OrderedRtpPacket> {
        self.output.pop_front()
    }

    /// Take the next packet from the buffer.
    ///
    /// This method will skip missing packets if necessary.
    fn take(&mut self) -> Option<OrderedRtpPacket> {
        while self.output.is_empty() {
            if self.buffer.is_empty() {
                break;
            } else if let Some(packet) = self.buffer.take() {
                self.push_ordered(packet);
            }
        }

        self.output.pop_front()
    }

    /// Get reception statistics for a given SSRC.
    fn get_stats_mut(&mut self, ssrc: u32) -> &mut SSRCRxStats {
        // helper function
        fn create_rx_stats(ssrc: u32, options: &RtpReceiverOptions) -> SSRCRxStats {
            let clock_rate = options
                .input_ssrcs
                .get(&ssrc)
                .copied()
                .unwrap_or(options.default_clock_rate);

            SSRCRxStats::new(ssrc, clock_rate)
        }

        self.stats
            .get_or_insert_mut(ssrc, || create_rx_stats(ssrc, &self.options))
    }

    /// Create a receiver report.
    fn create_receiver_report(&mut self) -> RtcpPacket {
        let report = ReceiverReport::new(self.options.sender_ssrc);

        let mut report_blocks = Vec::new();

        let mut size = report.raw_size();

        let mut report_order = self
            .stats
            .iter()
            .map(|(&ssrc, stats)| {
                let duration_since_last_report = stats
                    .last_receiver_report_at()
                    .map(|t| t.elapsed())
                    .unwrap_or(Duration::MAX);

                (ssrc, duration_since_last_report)
            })
            .collect::<Vec<_>>();

        report_order.sort_unstable_by_key(|&(_, d)| d);

        while let Some((ssrc, _)) = report_order.pop() {
            let is_full = report_blocks.len() >= 31
                || (size + ReportBlock::RAW_SIZE) > self.options.max_rtcp_packet_size;

            if is_full {
                break;
            }

            if let Some(stats) = self.stats.peek_mut(&ssrc) {
                if let Some(mut block) = stats.create_rtcp_report() {
                    let ssrc = if self.options.input_ssrc_mode == SSRCMode::Ignore {
                        self.last_ssrc.unwrap_or(ssrc)
                    } else {
                        ssrc
                    };

                    block = block.with_ssrc(ssrc);

                    size += block.raw_size();

                    report_blocks.push(block);
                }
            }
        }

        report
            .with_report_blocks(report_blocks)
            .encode()
    }

    /// Process a given sender report.
    fn process_sender_report(&mut self, report: &SenderReport) {
        if let Some(stats) = self.stats.peek_mut(&report.sender_ssrc()) {
            stats.process_sender_report(report);
        }
    }
}

/// RTP receiver statistics for a single SSRC.
#[derive(Clone)]
pub struct SSRCRxStats {
    ssrc: u32,
    clock_rate: u32,
    received_packets: u64,
    first_rtp_packet_at: Option<Instant>,
    first_rtp_timestamp: Option<u32>,
    last_transit_time: i32,
    jitter_estimate: u32,
    first_esn: Option<u64>,
    last_esn: Option<u64>,
    last_rr_at: Option<Instant>,
    last_sr_at: Option<Instant>,
    last_sr_ntp_timestamp: u64,
    create_report: bool,
}

impl SSRCRxStats {
    /// Create new RTP receiver statistics.
    pub fn new(ssrc: u32, clock_rate: u32) -> Self {
        Self {
            ssrc,
            clock_rate,
            received_packets: 0,
            first_rtp_packet_at: None,
            first_rtp_timestamp: None,
            last_transit_time: 0,
            jitter_estimate: 0,
            first_esn: None,
            last_esn: None,
            last_rr_at: None,
            last_sr_at: None,
            last_sr_ntp_timestamp: 0,
            create_report: false,
        }
    }

    /// Process a given incoming RTP packet.
    pub fn process_incoming_packet(&mut self, packet: &IncomingRtpPacket) {
        self.received_packets = self.received_packets.wrapping_add(1);

        if self.first_rtp_packet_at.is_none() {
            self.first_rtp_packet_at = Some(Instant::now());
        }

        let packet_ts = packet.timestamp();

        if self.first_rtp_timestamp.is_none() {
            self.first_rtp_timestamp = Some(packet_ts);
        }

        let arrival_ts = self.current_rtp_time();

        let transit_time = arrival_ts.wrapping_sub(packet_ts) as i32;

        self.jitter_estimate = self
            .jitter_estimate
            .wrapping_add(i32::unsigned_abs(transit_time - self.last_transit_time))
            .wrapping_sub((self.jitter_estimate + 8) >> 4);

        self.last_transit_time = transit_time;
    }

    /// Process a given incoming RTP packet after reordering.
    pub fn process_ordered_packet(&mut self, packet: &OrderedRtpPacket) {
        let index = packet.index();

        if self.first_esn.is_none() {
            self.first_esn = Some(index);
        }

        self.last_esn = Some(index);

        self.create_report = true;
    }

    /// Process a given sender report.
    pub fn process_sender_report(&mut self, report: &SenderReport) {
        self.last_sr_at = Some(Instant::now());
        self.last_sr_ntp_timestamp = report.ntp_timestamp();
    }

    /// Create an RTCP receiver report block if there is anything to report.
    pub fn create_rtcp_report(&mut self) -> Option<ReportBlock> {
        let expected_packets = self.expected_packets();
        let highest_esn = self.highest_esn()?;

        if !self.create_report {
            return None;
        }

        self.create_report = false;

        self.last_rr_at = Some(Instant::now());

        let jitter = self.jitter_estimate >> 4;

        let delay_since_last_sr = self
            .last_sr_at
            .map(|t| t.elapsed())
            .unwrap_or(Duration::ZERO);

        let res = ReportBlock::new(self.ssrc)
            .with_loss(expected_packets, self.received_packets)
            .with_extended_sequence_number(highest_esn)
            .with_jitter(jitter)
            .with_last_sr_timestamp(self.last_sr_ntp_timestamp)
            .with_delay_since_last_sr(delay_since_last_sr);

        Some(res)
    }

    /// Get the instant of the last receiver report.
    pub fn last_receiver_report_at(&self) -> Option<Instant> {
        self.last_rr_at
    }

    /// Get the number of packets expected by the receiver.
    fn expected_packets(&self) -> u64 {
        if let Some(last) = self.last_esn {
            last - self.first_esn.unwrap_or(last) + 1
        } else {
            0
        }
    }

    /// Get the highest extended sequence number received.
    fn highest_esn(&self) -> Option<u32> {
        self.last_esn.map(|val| val as u32)
    }

    /// Get the current RTP timestamp.
    ///
    /// The timestamp corresponds to the time elapsed since the first RTP
    /// packet was received and it is in the SSRC clock rate.
    fn current_rtp_time(&self) -> u32 {
        let elapsed = self
            .first_rtp_packet_at
            .map(|instant| instant.elapsed())
            .unwrap_or(Duration::ZERO);

        self.first_rtp_timestamp
            .unwrap_or(0)
            .wrapping_add(elapsed.to_rtp_time(self.clock_rate))
    }
}
